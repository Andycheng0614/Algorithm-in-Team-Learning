#include "CountingSort.h"
#include <iostream>
#include <vector>

using namespace std;

/************************************************************************/
/*函数名：CountingSort
/*功  能：计数排序
/*返回值：无
/************************************************************************/
void CountingSort(int *A, int *B, int *C, const int SIZE)
{
	vector<int> D(10, 0); // 创建D数组并初始化

	// D的坐标对应A中元素的值，统计A中元素的个数
	for (int i = 0; i < SIZE; i++)
		D[C[i]]++;

	// D中计数累加，此时C[i]对应D中的A[i]处
	// D[i]包含等于i的元素个数
	for (int i = 1; i < 10; ++i)
		D[i] += D[i - 1];

	// 而D[A[i]]存的元素即为A[i]在B中的正确位置
	// 数组下标应从0开始，因此用D[A[j]]减去1
	// D[i]包含小于等于i的元素个数
	for (int i = SIZE - 1; i >= 0; i--)
	{
		B[D[C[i]] - 1] = A[i];
		D[C[i]] = D[C[i]] - 1; // 有相同元素的话，相同元素依次前移
	}
}

/************************************************************************/
/*函数名：CountingSort
/*功  能：计数排序
/*返回值：无
/************************************************************************/
void CountingSortOpt(int *A, int *B, int *C, const int SIZE)
{
	vector<int> D(256, 0); // 创建D数组并初始化

	// D的坐标对应A中元素的值，统计A中元素的个数
	for (int i = 0; i < SIZE; i++)
		D[C[i]]++;

	// D中计数累加，此时C[i]对应D中的A[i]处
	// D[i]包含等于i的元素个数
	for (int i = 1; i < 256; ++i)
		D[i] += D[i - 1];

	// 而D[A[i]]存的元素即为A[i]在B中的正确位置
	// 数组下标应从0开始，因此用D[A[j]]减去1
	// D[i]包含小于等于i的元素个数
	for (int i = SIZE - 1; i >= 0; i--)
	{
		B[D[C[i]] - 1] = A[i];
		D[C[i]] = D[C[i]] - 1; // 有相同元素的话，相同元素依次前移
	}
}